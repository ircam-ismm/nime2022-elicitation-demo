"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("events"),t=require("cluster"),r=require("worker_threads"),s=require("async_hooks");function o(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var i,n=o(e),a=o(t);!function(e){e.FIXED="fixed",e.DYNAMIC="dynamic"}(i||(i={}));class h extends n.default{}const c=()=>{},l=Object.freeze({SOFT:"SOFT",HARD:"HARD"});const k=Object.freeze({ROUND_ROBIN:"ROUND_ROBIN",LESS_RECENTLY_USED:"LESS_RECENTLY_USED"});class u{constructor(e){this.pool=e,this.nextWorkerIndex=0}choose(){const e=this.pool.workers[this.nextWorkerIndex];return this.nextWorkerIndex=this.pool.workers.length-1===this.nextWorkerIndex?0:this.nextWorkerIndex+1,e}}class p{constructor(e){this.pool=e}choose(){const e=this.pool.type===i.DYNAMIC;let t,r=1/0;for(const[s,o]of this.pool.tasks){if(!e&&0===o)return s;o<r&&(t=s,r=o)}return t}}class d{constructor(e,t,r=k.ROUND_ROBIN){this.pool=e,this.createDynamicallyWorkerCallback=t,this.workerChoiceStrategy=W.getWorkerChoiceStrategy(this.pool,r)}choose(){const e=this.pool.findFreeTasksMapEntry();return e?e[0]:this.pool.busy?this.workerChoiceStrategy.choose():this.createDynamicallyWorkerCallback()}}class y{constructor(e,t,r=k.ROUND_ROBIN){this.pool=e,this.createDynamicallyWorkerCallback=t,this.setWorkerChoiceStrategy(r)}getPoolWorkerChoiceStrategy(e=k.ROUND_ROBIN){return this.pool.type===i.DYNAMIC?new d(this.pool,this.createDynamicallyWorkerCallback,e):W.getWorkerChoiceStrategy(this.pool,e)}setWorkerChoiceStrategy(e){this.workerChoiceStrategy=this.getPoolWorkerChoiceStrategy(e)}execute(){return this.workerChoiceStrategy.choose()}}class W{static getWorkerChoiceStrategy(e,t=k.ROUND_ROBIN){switch(t){case k.ROUND_ROBIN:return new u(e);case k.LESS_RECENTLY_USED:return new p(e);default:throw new Error(`Worker choice strategy '${t}' not found`)}}}class m{constructor(e,t,r){if(this.numberOfWorkers=e,this.filePath=t,this.opts=r,this.workers=[],this.tasks=new Map,this.promiseMap=new Map,this.nextMessageId=0,!this.isMain())throw new Error("Cannot start a pool from a worker!");this.checkNumberOfWorkers(this.numberOfWorkers),this.checkFilePath(this.filePath),this.checkPoolOptions(this.opts),this.setupHook();for(let e=1;e<=this.numberOfWorkers;e++)this.createAndSetupWorker();this.opts.enableEvents&&(this.emitter=new h),this.workerChoiceStrategyContext=new y(this,(()=>{const e=this.createAndSetupWorker();return this.registerWorkerMessageListener(e,(async t=>{const r=this.tasks.get(e);var s;s=l.HARD,(t.kill===s||0===r)&&await this.destroyWorker(e)})),e}),this.opts.workerChoiceStrategy)}checkFilePath(e){if(!e)throw new Error("Please specify a file with a worker implementation")}checkNumberOfWorkers(e){if(null==e)throw new Error("Cannot instantiate a pool without specifying the number of workers");if(!Number.isSafeInteger(e))throw new Error("Cannot instantiate a pool with a non integer number of workers");if(e<0)throw new Error("Cannot instantiate a pool with a negative number of workers");if(this.type===i.FIXED&&0===e)throw new Error("Cannot instantiate a fixed pool with no worker")}checkPoolOptions(e){var t,r;this.opts.workerChoiceStrategy=null!==(t=e.workerChoiceStrategy)&&void 0!==t?t:k.ROUND_ROBIN,this.opts.enableEvents=null===(r=e.enableEvents)||void 0===r||r}get numberOfRunningTasks(){return this.promiseMap.size}setWorkerChoiceStrategy(e){this.opts.workerChoiceStrategy=e,this.workerChoiceStrategyContext.setWorkerChoiceStrategy(e)}internalGetBusyStatus(){return this.numberOfRunningTasks>=this.numberOfWorkers&&!1===this.findFreeTasksMapEntry()}findFreeTasksMapEntry(){for(const[e,t]of this.tasks)if(0===t)return[e,t];return!1}execute(e){const t=this.chooseWorker(),r=++this.nextMessageId,s=this.internalExecute(t,r);return this.checkAndEmitBusy(),this.sendToWorker(t,{data:e||{},id:r}),s}async destroy(){await Promise.all(this.workers.map((e=>this.destroyWorker(e))))}setupHook(){}increaseWorkersTask(e){this.stepWorkerNumberOfTasks(e,1)}decreaseWorkersTasks(e){this.stepWorkerNumberOfTasks(e,-1)}stepWorkerNumberOfTasks(e,t){const r=this.tasks.get(e);if(void 0===r)throw Error("Worker could not be found in tasks map");this.tasks.set(e,r+t)}removeWorker(e){const t=this.workers.indexOf(e);this.workers.splice(t,1),this.tasks.delete(e)}chooseWorker(){return this.workerChoiceStrategyContext.execute()}internalExecute(e,t){return this.increaseWorkersTask(e),new Promise(((r,s)=>{this.promiseMap.set(t,{resolve:r,reject:s,worker:e})}))}createAndSetupWorker(){var e,t,r,s;const o=this.createWorker();return o.on("message",null!==(e=this.opts.messageHandler)&&void 0!==e?e:c),o.on("error",null!==(t=this.opts.errorHandler)&&void 0!==t?t:c),o.on("online",null!==(r=this.opts.onlineHandler)&&void 0!==r?r:c),o.on("exit",null!==(s=this.opts.exitHandler)&&void 0!==s?s:c),o.once("exit",(()=>this.removeWorker(o))),this.workers.push(o),this.tasks.set(o,0),this.afterWorkerSetup(o),o}workerListener(){return e=>{if(e.id){const t=this.promiseMap.get(e.id);t&&(this.decreaseWorkersTasks(t.worker),e.error?t.reject(e.error):t.resolve(e.data),this.promiseMap.delete(e.id))}}}checkAndEmitBusy(){var e;this.opts.enableEvents&&this.busy&&(null===(e=this.emitter)||void 0===e||e.emit("busy"))}}class w extends m{constructor(e,t,r={}){super(e,t,r),this.opts=r}setupHook(){a.default.setupPrimary({exec:this.filePath})}isMain(){return a.default.isPrimary}destroyWorker(e){this.sendToWorker(e,{kill:1}),e.kill()}sendToWorker(e,t){e.send(t)}registerWorkerMessageListener(e,t){e.on("message",t)}createWorker(){return a.default.fork(this.opts.env)}afterWorkerSetup(e){this.registerWorkerMessageListener(e,super.workerListener())}get type(){return i.FIXED}get busy(){return this.internalGetBusyStatus()}}class f extends m{constructor(e,t,r={}){super(e,t,r)}isMain(){return r.isMainThread}async destroyWorker(e){this.sendToWorker(e,{kill:1}),await e.terminate()}sendToWorker(e,t){e.postMessage(t)}registerWorkerMessageListener(e,t){var r;null===(r=e.port2)||void 0===r||r.on("message",t)}createWorker(){return new r.Worker(this.filePath,{env:r.SHARE_ENV})}afterWorkerSetup(e){const{port1:t,port2:s}=new r.MessageChannel;e.postMessage({parent:t},[t]),e.port1=t,e.port2=s,this.registerWorkerMessageListener(e,super.workerListener())}get type(){return i.FIXED}get busy(){return this.internalGetBusyStatus()}}const g=l.SOFT;class v extends s.AsyncResource{constructor(e,t,r,s,o={killBehavior:g,maxInactiveTime:6e4}){var i,n;super(e),this.mainWorker=s,this.opts=o,this.checkFunctionInput(r),this.checkWorkerOptions(this.opts),this.lastTaskTimestamp=Date.now(),t||(this.aliveInterval=setInterval(this.checkAlive.bind(this),(null!==(i=this.opts.maxInactiveTime)&&void 0!==i?i:6e4)/2),this.checkAlive.bind(this)()),null===(n=this.mainWorker)||void 0===n||n.on("message",(e=>{(null==e?void 0:e.data)&&e.id?this.opts.async?this.runInAsyncScope(this.runAsync.bind(this),this,r,e):this.runInAsyncScope(this.run.bind(this),this,r,e):e.parent?this.mainWorker=e.parent:e.kill&&(this.aliveInterval&&clearInterval(this.aliveInterval),this.emitDestroy())}))}checkWorkerOptions(e){var t,r;this.opts.killBehavior=null!==(t=e.killBehavior)&&void 0!==t?t:g,this.opts.maxInactiveTime=null!==(r=e.maxInactiveTime)&&void 0!==r?r:6e4,this.opts.async=!!e.async}checkFunctionInput(e){if(!e)throw new Error("fn parameter is mandatory")}getMainWorker(){if(!this.mainWorker)throw new Error("Main worker was not set");return this.mainWorker}checkAlive(){var e;Date.now()-this.lastTaskTimestamp>(null!==(e=this.opts.maxInactiveTime)&&void 0!==e?e:6e4)&&this.sendToMainWorker({kill:this.opts.killBehavior})}handleError(e){return e}run(e,t){try{const r=e(t.data);this.sendToMainWorker({data:r,id:t.id})}catch(e){const r=this.handleError(e);this.sendToMainWorker({error:r,id:t.id})}finally{this.lastTaskTimestamp=Date.now()}}runAsync(e,t){e(t.data).then((e=>(this.sendToMainWorker({data:e,id:t.id}),null))).catch((e=>{const r=this.handleError(e);this.sendToMainWorker({error:r,id:t.id})})).finally((()=>{this.lastTaskTimestamp=Date.now()})).catch(c)}}exports.AbstractWorker=v,exports.ClusterWorker=class extends v{constructor(e,t={}){super("worker-cluster-pool:poolifier",a.default.isPrimary,e,a.default.worker,t)}sendToMainWorker(e){this.getMainWorker().send(e)}handleError(e){return e instanceof Error?e.message:e}},exports.DynamicClusterPool=class extends w{constructor(e,t,r,s={}){super(e,r,s),this.max=t}get type(){return i.DYNAMIC}get busy(){return this.workers.length===this.max}},exports.DynamicThreadPool=class extends f{constructor(e,t,r,s={}){super(e,r,s),this.max=t}get type(){return i.DYNAMIC}get busy(){return this.workers.length===this.max}},exports.FixedClusterPool=w,exports.FixedThreadPool=f,exports.KillBehaviors=l,exports.ThreadWorker=class extends v{constructor(e,t={}){super("worker-thread-pool:poolifier",r.isMainThread,e,r.parentPort,t)}sendToMainWorker(e){this.getMainWorker().postMessage(e)}},exports.WorkerChoiceStrategies=k;
